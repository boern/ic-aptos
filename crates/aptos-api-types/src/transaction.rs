// Copyright © Aptos Foundation
// Parts of the project are originally copyright © Meta Platforms, Inc.
// SPDX-License-Identifier: Apache-2.0

use crate::{
    move_types::{
        EntryFunctionId, HexEncodedBytes, MoveModuleBytecode, MoveModuleId, MoveResource,
        MoveScriptBytecode, MoveStructTag, MoveType,
    },
    wrappers::EventGuid,
    Address, AptosError, HashValue, U64,
};
use anyhow::{bail, Context as AnyhowContext, Result};
use aptos_crypto::ed25519::{self, Ed25519PublicKey};
use aptos_types::transaction::authenticator::{AccountAuthenticator, TransactionAuthenticator};

use serde::{Deserialize, Serialize};
use std::{
    convert::{From, Into, TryFrom, TryInto},
    fmt,
    str::FromStr,
};

/// Enum of the different types of transactions in Aptos
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
// //#[oai(one_of, discriminator_name = "type", rename_all = "snake_case")]
pub enum Transaction {
    PendingTransaction(PendingTransaction),
    UserTransaction(UserTransaction),
}

impl Transaction {
    pub fn timestamp(&self) -> u64 {
        match self {
            Transaction::PendingTransaction(_) => 0,
            Transaction::UserTransaction(txn) => txn.timestamp.0,
        }
    }

    pub fn version(&self) -> Option<u64> {
        match self {
            Transaction::PendingTransaction(_) => None,
            Transaction::UserTransaction(txn) => Some(txn.info.version.into()),
        }
    }

    pub fn success(&self) -> bool {
        match self {
            Transaction::PendingTransaction(_txn) => false,
            Transaction::UserTransaction(txn) => txn.info.success,
        }
    }

    pub fn is_pending(&self) -> bool {
        matches!(self, Transaction::PendingTransaction(_))
    }

    pub fn vm_status(&self) -> String {
        match self {
            Transaction::PendingTransaction(_txn) => "pending".to_owned(),
            Transaction::UserTransaction(txn) => txn.info.vm_status.clone(),
        }
    }

    pub fn type_str(&self) -> &'static str {
        match self {
            Transaction::PendingTransaction(_) => "pending_transaction",
            Transaction::UserTransaction(_) => "user_transaction",
        }
    }

    pub fn transaction_info(&self) -> anyhow::Result<&TransactionInfo> {
        Ok(match self {
            Transaction::PendingTransaction(_txn) => {
                bail!("pending transaction does not have TransactionInfo")
            }
            Transaction::UserTransaction(txn) => &txn.info,
        })
    }
}

/// Information related to how a transaction affected the state of the blockchain
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct TransactionInfo {
    pub version: U64,
    pub hash: HashValue,
    pub state_change_hash: HashValue,
    pub event_root_hash: HashValue,
    pub state_checkpoint_hash: Option<HashValue>,
    pub gas_used: U64,
    /// Whether the transaction was successful
    pub success: bool,
    /// The VM status of the transaction, can tell useful information in a failure
    pub vm_status: String,
    pub accumulator_root_hash: HashValue,
    /// Final state of resources changed by the transaction
    pub changes: Vec<WriteSetChange>,
    /// Block height that the transaction belongs in, this field will not be present through the API
    // //#[oai(skip)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub block_height: Option<U64>,
    /// Epoch of the transaction belongs in, this field will not be present through the API
    // //#[oai(skip)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub epoch: Option<U64>,
}

/// A transaction waiting in mempool
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct PendingTransaction {
    pub hash: HashValue,
    #[serde(flatten)]
    //// //#[oai(flatten)]
    pub request: UserTransactionRequest,
}

// impl From<(SignedTransaction, TransactionPayload)> for PendingTransaction {
//     fn from((txn, payload): (SignedTransaction, TransactionPayload)) -> Self {
//         PendingTransaction {
//             request: (&txn, payload).into(),
//             hash: txn.committed_hash().into(),
//         }
//     }
// }

/// A transaction submitted by a user to change the state of the blockchain
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct UserTransaction {
    #[serde(flatten)]
    //// //#[oai(flatten)]
    pub info: TransactionInfo,
    #[serde(flatten)]
    //// //#[oai(flatten)]
    pub request: UserTransactionRequest,
    /// Events generated by the transaction
    pub events: Vec<Event>,
    pub timestamp: U64,
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct BlockEndInfo {
    pub block_gas_limit_reached: bool,
    pub block_output_limit_reached: bool,
    pub block_effective_block_gas_units: u64,
    pub block_approx_output_size: u64,
}

/// Batch transaction submission result
///
/// Tells which transactions failed
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsBatchSubmissionResult {
    /// Summary of the failed transactions
    pub transaction_failures: Vec<TransactionsBatchSingleSubmissionFailure>,
}

/// Information telling which batch submission transactions failed
#[derive(Debug, Serialize, Deserialize)]
pub struct TransactionsBatchSingleSubmissionFailure {
    pub error: AptosError,
    /// The index of which transaction failed, same as submission order
    pub transaction_index: usize,
}

// TODO: Remove this when we cut over.
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct UserTransactionRequest {
    pub sender: Address,
    pub sequence_number: U64,
    pub max_gas_amount: U64,
    pub gas_unit_price: U64,
    pub expiration_timestamp_secs: U64,
    pub payload: TransactionPayload,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signature: Option<TransactionSignature>,
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct BlockMetadataExtensionEmpty {}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct BlockMetadataExtensionRandomness {
    randomness: Option<HexEncodedBytes>,
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
//#[oai(one_of, discriminator_name = "type", rename_all = "snake_case")]
pub enum BlockMetadataExtension {
    V0(BlockMetadataExtensionEmpty),
    V1(BlockMetadataExtensionRandomness),
}

/// An event from a transaction
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct Event {
    // The globally unique identifier of this event stream.
    pub guid: EventGuid,
    // The sequence number of the event
    pub sequence_number: U64,
    #[serde(rename = "type")]
    //#[oai(rename = "type")]
    pub typ: MoveType,
    /// The JSON representation of the event
    pub data: serde_json::Value,
}

/// An enum of the possible transaction payloads
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
//#[oai(one_of, discriminator_name = "type", rename_all = "snake_case")]
pub enum TransactionPayload {
    EntryFunctionPayload(EntryFunctionPayload),
    ScriptPayload(ScriptPayload),
}

/// Payload which runs a single entry function
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct EntryFunctionPayload {
    pub function: EntryFunctionId,
    /// Type arguments of the function
    pub type_arguments: Vec<MoveType>,
    /// Arguments of the function
    pub arguments: Vec<serde_json::Value>,
}

/// Payload which runs a script that can run multiple functions
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct ScriptPayload {
    pub code: MoveScriptBytecode,
    /// Type arguments of the function
    pub type_arguments: Vec<MoveType>,
    /// Arguments of the function
    pub arguments: Vec<serde_json::Value>,
}

/// A final state change of a transaction on a resource or module
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
//#[oai(one_of, discriminator_name = "type", rename_all = "snake_case")]
pub enum WriteSetChange {
    DeleteModule(DeleteModule),
    DeleteResource(DeleteResource),
    DeleteTableItem(DeleteTableItem),
    WriteModule(WriteModule),
    WriteResource(WriteResource),
    WriteTableItem(WriteTableItem),
}

/// Delete a module
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct DeleteModule {
    pub address: Address,
    /// State key hash
    pub state_key_hash: String,
    pub module: MoveModuleId,
}

/// Delete a resource
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct DeleteResource {
    pub address: Address,
    /// State key hash
    pub state_key_hash: String,
    pub resource: MoveStructTag,
}

/// Delete a table item
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct DeleteTableItem {
    pub state_key_hash: String,
    pub handle: HexEncodedBytes,
    pub key: HexEncodedBytes,
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DeletedTableData>,
}

/// Write a new module or update an existing one
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct WriteModule {
    pub address: Address,
    /// State key hash
    pub state_key_hash: String,
    pub data: MoveModuleBytecode,
}

/// Write a resource or update an existing one
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct WriteResource {
    pub address: Address,
    /// State key hash
    pub state_key_hash: String,
    pub data: MoveResource,
}

/// Decoded table data
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct DecodedTableData {
    /// Key of table in JSON
    pub key: serde_json::Value,
    /// Type of key
    pub key_type: String,
    /// Value of table in JSON
    pub value: serde_json::Value,
    /// Type of value
    pub value_type: String,
}

/// Deleted table data
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct DeletedTableData {
    /// Deleted key
    pub key: serde_json::Value,
    /// Deleted key type
    pub key_type: String,
}

/// Change set to write a table item
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct WriteTableItem {
    pub state_key_hash: String,
    pub handle: HexEncodedBytes,
    pub key: HexEncodedBytes,
    pub value: HexEncodedBytes,
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DecodedTableData>,
}

/// An enum representing the different transaction signatures available
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
//#[oai(one_of, discriminator_name = "type", rename_all = "snake_case")]
pub enum TransactionSignature {
    Ed25519Signature(Ed25519Signature),
}

impl TryFrom<TransactionSignature> for TransactionAuthenticator {
    type Error = anyhow::Error;

    fn try_from(ts: TransactionSignature) -> anyhow::Result<Self> {
        Ok(match ts {
            TransactionSignature::Ed25519Signature(sig) => sig.try_into()?,
        })
    }
}

/// A single Ed25519 signature
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Ed25519Signature {
    pub public_key: HexEncodedBytes,
    pub signature: HexEncodedBytes,
}

impl TryFrom<Ed25519Signature> for TransactionAuthenticator {
    type Error = anyhow::Error;

    fn try_from(value: Ed25519Signature) -> Result<Self, Self::Error> {
        let Ed25519Signature {
            public_key,
            signature,
        } = value;
        Ok(TransactionAuthenticator::ed25519(
            public_key
                .inner()
                .try_into()
                .context("Failed to parse given public_key bytes as a Ed25519PublicKey")?,
            signature
                .inner()
                .try_into()
                .context("Failed to parse given signature as a Ed25519Signature")?,
        ))
    }
}

impl TryFrom<Ed25519Signature> for AccountAuthenticator {
    type Error = anyhow::Error;

    fn try_from(value: Ed25519Signature) -> Result<Self, Self::Error> {
        let Ed25519Signature {
            public_key,
            signature,
        } = value;
        Ok(AccountAuthenticator::ed25519(
            public_key
                .inner()
                .try_into()
                .context("Failed to parse given public_key bytes as a Ed25519PublicKey")?,
            signature
                .inner()
                .try_into()
                .context("Failed to parse given signature as a Ed25519Signature")?,
        ))
    }
}

/// A Ed25519 multi-sig signature
///
/// This allows k-of-n signing for a transaction
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MultiEd25519Signature {
    /// The public keys for the Ed25519 signature
    pub public_keys: Vec<HexEncodedBytes>,
    /// Signature associated with the public keys in the same order
    pub signatures: Vec<HexEncodedBytes>,
    /// The number of signatures required for a successful transaction
    pub threshold: u8,
    pub bitmap: HexEncodedBytes,
}

/// A single Secp256k1Ecdsa signature
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Secp256k1EcdsaSignature {
    pub public_key: HexEncodedBytes,
    pub signature: HexEncodedBytes,
}

/// A single WebAuthn signature
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct WebAuthnSignature {
    pub public_key: HexEncodedBytes,
    pub signature: HexEncodedBytes,
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct KeylessSignature {
    pub public_key: HexEncodedBytes,
    pub signature: HexEncodedBytes,
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
//#[oai(one_of, discriminator_name = "type", rename_all = "snake_case")]
pub enum Signature {
    Ed25519(Ed25519),
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Ed25519 {
    pub value: HexEncodedBytes,
}

impl Ed25519 {
    pub fn new(value: HexEncodedBytes) -> Self {
        Self { value }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Secp256k1Ecdsa {
    pub value: HexEncodedBytes,
}

impl Secp256k1Ecdsa {
    pub fn new(value: HexEncodedBytes) -> Self {
        Self { value }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Secp256r1Ecdsa {
    pub value: HexEncodedBytes,
}

impl Secp256r1Ecdsa {
    pub fn new(value: HexEncodedBytes) -> Self {
        Self { value }
    }
}
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct WebAuthn {
    pub value: HexEncodedBytes,
}

impl WebAuthn {
    pub fn new(value: HexEncodedBytes) -> Self {
        Self { value }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct Keyless {
    pub value: HexEncodedBytes,
}

impl Keyless {
    pub fn new(value: HexEncodedBytes) -> Self {
        Self { value }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct FederatedKeyless {
    pub value: HexEncodedBytes,
}

impl FederatedKeyless {
    pub fn new(value: HexEncodedBytes) -> Self {
        Self { value }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
//#[oai(one_of, discriminator_name = "type", rename_all = "snake_case")]
pub enum PublicKey {
    Ed25519(Ed25519),
    // Secp256k1Ecdsa(Secp256k1Ecdsa),
    // Secp256r1Ecdsa(Secp256r1Ecdsa),
    // Keyless(Keyless),
    // FederatedKeyless(FederatedKeyless),
}

/// A single key signature
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct SingleKeySignature {
    pub public_key: PublicKey,
    pub signature: Signature,
}

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct IndexedSignature {
    pub index: u8,
    pub signature: Signature,
}

/// A multi key signature
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MultiKeySignature {
    pub public_keys: Vec<PublicKey>,
    pub signatures: Vec<IndexedSignature>,
    pub signatures_required: u8,
}

/// A placeholder to represent the absence of account signature
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct NoAccountSignature;

/// Account signature scheme
///
/// The account signature scheme allows you to have two types of accounts:
///
///   1. A single Ed25519 key account, one private key
///   2. A k-of-n multi-Ed25519 key account, multiple private keys, such that k-of-n must sign a transaction.
///   3. A single Secp256k1Ecdsa key account, one private key
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
//#[oai(one_of, discriminator_name = "type", rename_all = "snake_case")]
pub enum AccountSignature {
    Ed25519Signature(Ed25519Signature),
    // MultiEd25519Signature(MultiEd25519Signature),
    // SingleKeySignature(SingleKeySignature),
    // MultiKeySignature(MultiKeySignature),
    // NoAccountSignature(NoAccountSignature),
}

impl TryFrom<AccountSignature> for AccountAuthenticator {
    type Error = anyhow::Error;

    fn try_from(sig: AccountSignature) -> anyhow::Result<Self> {
        Ok(match sig {
            AccountSignature::Ed25519Signature(s) => s.try_into()?,
            // AccountSignature::MultiEd25519Signature(s) => s.try_into()?,
            // AccountSignature::SingleKeySignature(s) => s.try_into()?,
            // AccountSignature::MultiKeySignature(s) => s.try_into()?,
            // AccountSignature::NoAccountSignature(s) => s.try_into()?,
        })
    }
}

/// Multi agent signature for multi agent transactions
///
/// This allows you to have transactions across multiple accounts
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct MultiAgentSignature {
    pub sender: AccountSignature,
    /// The other involved parties' addresses
    pub secondary_signer_addresses: Vec<Address>,
    /// The associated signatures, in the same order as the secondary addresses
    pub secondary_signers: Vec<AccountSignature>,
}

impl From<(&Ed25519PublicKey, &ed25519::Ed25519Signature)> for Ed25519Signature {
    fn from((pk, sig): (&Ed25519PublicKey, &ed25519::Ed25519Signature)) -> Self {
        Self {
            public_key: pk.to_bytes().to_vec().into(),
            signature: sig.to_bytes().to_vec().into(),
        }
    }
}

/// Fee payer signature for fee payer transactions
///
/// This allows you to have transactions across multiple accounts and with a fee payer
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct FeePayerSignature {
    pub sender: AccountSignature,
    /// The other involved parties' addresses
    pub secondary_signer_addresses: Vec<Address>,
    /// The associated signatures, in the same order as the secondary addresses
    pub secondary_signers: Vec<AccountSignature>,
    /// The address of the paying party
    pub fee_payer_address: Address,
    /// The signature of the fee payer
    pub fee_payer_signer: AccountSignature,
}

/// A transaction identifier
///
/// There are 2 types transaction ids from HTTP request inputs:
/// 1. Transaction hash: hex-encoded string, e.g. "0x374eda71dce727c6cd2dd4a4fd47bfb85c16be2e3e95ab0df4948f39e1af9981"
/// 2. Transaction version: u64 number string (as we encode u64 into string in JSON), e.g. "122"
#[derive(Clone, Debug)]
//#[oai(one_of, discriminator_name = "type", rename_all = "snake_case")]
pub enum TransactionId {
    Hash(HashValue),
    Version(U64),
}

impl FromStr for TransactionId {
    type Err = anyhow::Error;

    fn from_str(hash_or_version: &str) -> Result<Self, anyhow::Error> {
        let id = match hash_or_version.parse::<u64>() {
            Ok(version) => TransactionId::Version(U64::from(version)),
            Err(_) => TransactionId::Hash(hash_or_version.parse()?),
        };
        Ok(id)
    }
}

impl fmt::Display for TransactionId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Self::Hash(h) => write!(f, "hash({})", h),
            Self::Version(v) => write!(f, "version({})", v),
        }
    }
}

/// A hex encoded BCS encoded transaction from the EncodeSubmission API
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct TransactionSigningMessage {
    pub message: HexEncodedBytes,
}

impl TransactionSigningMessage {
    pub fn new(bytes: Vec<u8>) -> Self {
        Self {
            message: bytes.into(),
        }
    }
}

/// Struct holding the outputs of the estimate gas API
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct GasEstimationBcs {
    /// The current estimate for the gas unit price
    pub gas_estimate: u64,
}

/// Struct holding the outputs of the estimate gas API
#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct GasEstimation {
    /// The deprioritized estimate for the gas unit price
    pub deprioritized_gas_estimate: Option<u64>,
    /// The current estimate for the gas unit price
    pub gas_estimate: u64,
    /// The prioritized estimate for the gas unit price
    pub prioritized_gas_estimate: Option<u64>,
}
